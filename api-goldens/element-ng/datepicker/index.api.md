## Public API Report File for "@siemens/element-ng_datepicker"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractControl } from '@angular/forms';
import { AfterContentInit } from '@angular/core';
import { AfterViewInit } from '@angular/core';
import * as _angular_core from '@angular/core';
import * as _angular_forms from '@angular/forms';
import { ComponentRef } from '@angular/core';
import { ConnectionPositionPair } from '@angular/cdk/overlay';
import { ControlValueAccessor } from '@angular/forms';
import { DoCheck } from '@angular/core';
import { ElementRef } from '@angular/core';
import { FocusOrigin } from '@angular/cdk/a11y';
import { FormControl } from '@angular/forms';
import { NgControl } from '@angular/forms';
import { OnChanges } from '@angular/core';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import * as _siemens_element_translate_ng_translate_types from '@siemens/element-translate-ng/translate-types';
import { SiFormItemControl } from '@siemens/element-ng/form';
import { SimpleChanges } from '@angular/core';
import { TranslatableString } from '@siemens/element-translate-ng/translate';
import { ValidationErrors } from '@angular/forms';
import { Validator } from '@angular/forms';
import { ValidatorFn } from '@angular/forms';

// @public
export const addDays: (date: Date, days: number) => Date;

// @public
export const addDaysInRange: (current: Date, daysOffset: number, minDate?: Date, maxDate?: Date) => Date;

// @public
export const addMonthsInRange: (current: Date, monthsOffset: number, minDate?: Date, maxDate?: Date) => Date;

// @public
export const addYearsInRange: (current: Date, yearsOffset: number, minDate?: Date, maxDate?: Date) => Date;

// @public
export const changeDay: (date: Date, day: number) => Date;

// @public (undocumented)
export enum CloseCause {
    // (undocumented)
    Backdrop = "backdrop",
    // (undocumented)
    Detach = "detach",
    // (undocumented)
    Escape = "escape",
    // (undocumented)
    Select = "select"
}

// @public
export const compareDate: (first: Date, second: Date) => number;

// @public
export const compareMonth: (first: Date, second: Date) => number;

// @public
export const compareYear: (first: Date, second: Date) => number;

// @public
export const createDate: (value: Date, hours?: number, minutes?: number, seconds?: number, milliseconds?: number) => Date;

// @public (undocumented)
export interface DatepickerConfig {
    disabledTime?: boolean;
    disabledTimeText?: TranslatableString;
    enableDateRange?: boolean;
    enabledTimeText?: TranslatableString;
    enableTimeValidation?: boolean;
    enableTwoMonthDateRange?: boolean;
    // (undocumented)
    endTimeLabel?: string;
    // (undocumented)
    hideLabels?: boolean;
    hideWeekNumbers?: boolean;
    // (undocumented)
    hoursAriaLabel?: string;
    // (undocumented)
    hoursLabel?: string;
    // (undocumented)
    hoursPlaceholder?: string;
    mandatoryTime?: boolean;
    maxDate?: Date;
    // (undocumented)
    meridians?: string[];
    // (undocumented)
    meridiansAriaLabel?: string;
    // (undocumented)
    meridiansLabel?: string;
    // (undocumented)
    millisecondsAriaLabel?: string;
    // (undocumented)
    millisecondsLabel?: string;
    // (undocumented)
    millisecondsPlaceholder?: string;
    minDate?: Date;
    // (undocumented)
    minutesAriaLabel?: string;
    // (undocumented)
    minutesLabel?: string;
    // (undocumented)
    minutesPlaceholder?: string;
    onlyMonthSelection?: boolean;
    // (undocumented)
    secondsAriaLabel?: string;
    // (undocumented)
    secondsLabel?: string;
    // (undocumented)
    secondsPlaceholder?: string;
    showMilliseconds?: boolean;
    showMinutes?: boolean;
    showSeconds?: boolean;
    showTime?: boolean;
    // (undocumented)
    startTimeLabel?: string;
    todayText?: TranslatableString;
    weekStartDay?: WeekStart;
}

// @public (undocumented)
export type DatepickerInput = {
    config: DatepickerConfig;
    date: Date;
    dateRange: DateRange;
    rangeType: 'START' | 'END';
    time12h: boolean;
    showTime: true;
};

// @public (undocumented)
export interface DatepickerInputConfig extends DatepickerConfig {
    dateFormat?: string;
    dateTimeFormat?: string;
}

// @public
export type DatepickerInputPartial = Partial<DatepickerInput>;

// @public (undocumented)
export type DateRange = {
    start: Date | undefined;
    end: Date | undefined;
};

// @public (undocumented)
export interface DayOfWeek {
    // (undocumented)
    id: string;
    // (undocumented)
    index: number;
    // (undocumented)
    isWeekend: boolean;
    // (undocumented)
    offset: number;
}

// @public
export const daysInMonth: (month: number, year: number) => number;

// @public
export const getDatepickerFormat: (locale: string, config?: DatepickerInputConfig, timeWhenDisabled?: boolean) => string;

// @public
export const getDateSameOrBetween: (current: Date, minDate?: Date, maxDate?: Date) => Date;

// @public (undocumented)
export const getDateWithoutTime: (date: Date) => Date;

// @public (undocumented)
export const getDaysOfWeek: (weekStart: WeekStart) => DayOfWeek[];

// @public
export const getDayStrings: (locale: string, weekStart?: WeekStart, format?: "narrow" | "short" | "long") => string[];

// @public
export const getFirstDateInMonth: (current: Date) => Date;

// @public
export const getFirstDateInYear: (current: Date) => Date;

// @public
export const getFirstDayInMonth: (year: number, month: number) => Date;

// @public
export const getLastDateInMonth: (current: Date) => Date;

// @public
export const getLocaleMonthNames: (locale: string) => string[];

// @public
export const getMaxDate: (date?: Date) => Date;

// @public
export const getMinDate: (date?: Date) => Date;

// @public (undocumented)
export const getNamedFormat: (locale: string, format: string) => string;

// @public
export const getStringforDate: (date: Date) => string;

// @public (undocumented)
export const getWeekDayOffset: (date: Date, weekStart: WeekStart) => number;

// @public
export const getWeekEndDate: (current: Date, weekStartDay?: WeekStart) => Date;

// @public
export const getWeekOfYear: (date: Date, weekStart: WeekStart) => number;

// @public
export const getWeekStartDate: (current: Date, weekStartDay?: WeekStart) => Date;

// @public
export const is12HourFormat: (locale: string, config: DatepickerInputConfig) => boolean;

// @public
export const isAfter: (current: Date, compareTo: Date) => boolean;

// @public
export const isAfterMonth: (current: Date, compareTo: Date) => boolean;

// @public
export const isAfterYear: (current: Date, compareTo: Date) => boolean;

// @public
export const isAnotherMonth: (current: Date, compareTo: Date) => boolean;

// @public
export const isAnotherMonthOrYear: (current: Date, compareTo: Date) => boolean;

// @public
export const isAnotherYear: (current: Date, compareTo: Date) => boolean;

// @public
export const isBetween: (current: Date, from?: Date, to?: Date) => boolean;

// @public
export const isBetweenMonth: (current: Date, from?: Date, to?: Date) => boolean;

// @public
export const isBetweenYears: (current: Date, from?: Date, to?: Date) => boolean;

// @public
export const isSameDate: (current: Date, compareTo?: Date) => boolean;

// @public
export const isSameMonth: (current: Date, compareTo?: Date) => boolean;

// @public
export const isSameOrBefore: (current: Date, compareTo: Date) => boolean;

// @public
export const isSameOrBeforeMonth: (current: Date, compareTo: Date) => boolean;

// @public
export const isSameOrBeforeYear: (current: Date, compareTo: Date) => boolean;

// @public
export const isSameOrBetween: (current: Date, from?: Date, to?: Date) => boolean;

// @public
export const isSameOrBetweenMonth: (current: Date, from?: Date, to?: Date) => boolean;

// @public
export const isSameOrBetweenYears: (current: Date, from?: Date, to?: Date) => boolean;

// @public
export const isSameYear: (current: Date, compareTo?: Date) => boolean;

// @public
export const isValid: (date?: Date) => date is NonNullable<Date>;

// @public (undocumented)
export const maxDate: (first?: Date, second?: Date) => Date | undefined;

// @public (undocumented)
export const minDate: (first?: Date, second?: Date) => Date | undefined;

// @public
export const nextMonth: (date: Date) => Date;

// @public (undocumented)
export const parseDate: (input: string, format: string, locale: string) => Date | undefined;

// @public
export const previousMonth: (date: Date) => Date;

// @public (undocumented)
export type RangeType = 'START' | 'END' | undefined;

// @public
export class SiCalendarButtonComponent implements OnInit, AfterContentInit, DoCheck {
    readonly ariaLabel: _angular_core.InputSignal<_siemens_element_translate_ng_translate_types.TranslatableString>;
    // (undocumented)
    protected readonly button: _angular_core.Signal<ElementRef<HTMLButtonElement>>;
    protected readonly datepicker: _angular_core.Signal<SiDatepickerDirective>;
    // (undocumented)
    protected readonly datepickerOverlay: _angular_core.Signal<SiDatepickerOverlayDirective>;
    // (undocumented)
    protected readonly disabled: _angular_core.WritableSignal<boolean>;
    // (undocumented)
    protected readonly icons: Record<"elementCalendar", string>;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    protected readonly ngControl: _angular_core.Signal<NgControl | undefined>;
    // (undocumented)
    ngDoCheck(): void;
    // (undocumented)
    ngOnInit(): void;
    // (undocumented)
    protected show(): void;
    // (undocumented)
    protected readonly showValidationMessages: _angular_core.WritableSignal<boolean>;
    // (undocumented)
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<SiCalendarButtonComponent, "si-calendar-button", never, { "ariaLabel": { "alias": "ariaLabel"; "required": false; "isSignal": true; }; }, {}, ["datepicker", "datepickerOverlay", "ngControl"], ["*"], true, never>;
    // (undocumented)
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SiCalendarButtonComponent, never>;
}

// @public
export class SiDateInputDirective implements ControlValueAccessor, OnChanges, Validator, SiFormItemControl {
    // (undocumented)
    protected date?: Date;
    protected readonly dateChange: _angular_core.OutputEmitterRef<Date | undefined>;
    // (undocumented)
    protected readonly dateString: _angular_core.WritableSignal<string>;
    readonly disabledInput: _angular_core.InputSignal<boolean>;
    readonly errormessageId: _angular_core.InputSignal<string>;
    // (undocumented)
    readonly id: _angular_core.InputSignal<string>;
    // (undocumented)
    protected readonly locale: string;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    protected onBlur(event: FocusEvent): void;
    protected onDateChanged(date?: Date): void;
    protected onInput(event: Event): void;
    // (undocumented)
    protected onModelChange: (value: any) => void;
    // (undocumented)
    protected onTouched: () => void;
    readonly readonly: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    registerOnChange(fn: any): void;
    // (undocumented)
    registerOnTouched(fn: () => void): void;
    // (undocumented)
    registerOnValidatorChange(fn: () => void): void;
    // (undocumented)
    setDisabledState(isDisabled: boolean): void;
    readonly siDatepickerConfig: _angular_core.ModelSignal<DatepickerInputConfig | undefined>;
    readonly siDatepickerDisabledTime: _angular_core.OutputEmitterRef<boolean>;
    readonly stateChange: _angular_core.OutputEmitterRef<void>;
    // (undocumented)
    validate(c: AbstractControl): ValidationErrors | null;
    protected validator: _angular_forms.ValidatorFn;
    // (undocumented)
    writeValue(value?: Date | string): void;
    // (undocumented)
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<SiDateInputDirective, "input[siDateInput]", ["siDateInput"], { "id": { "alias": "id"; "required": false; "isSignal": true; }; "siDatepickerConfig": { "alias": "siDatepickerConfig"; "required": false; "isSignal": true; }; "disabledInput": { "alias": "disabled"; "required": false; "isSignal": true; }; "readonly": { "alias": "readonly"; "required": false; "isSignal": true; }; "errormessageId": { "alias": "errormessageId"; "required": false; "isSignal": true; }; }, { "siDatepickerConfig": "siDatepickerConfigChange"; "siDatepickerDisabledTime": "siDatepickerDisabledTime"; "stateChange": "stateChange"; "dateChange": "dateChange"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SiDateInputDirective, never>;
}

// @public (undocumented)
export class SiDatepickerComponent implements OnInit, OnChanges, AfterViewInit {
    constructor();
    protected activeMonthChange(selection: Date | null): void;
    protected activeYearChange(selection: Date | null): void;
    // (undocumented)
    protected readonly actualFocusedDate: _angular_core.Signal<Date>;
    readonly calendarWeekLabel: _angular_core.InputSignal<TranslatableString>;
    // @deprecated
    readonly calenderWeekLabel: _angular_core.InputSignal<TranslatableString | undefined>;
    readonly config: _angular_core.ModelSignal<DatepickerConfig>;
    readonly date: _angular_core.ModelSignal<Date | undefined>;
    readonly dateRange: _angular_core.ModelSignal<DateRange | undefined>;
    // (undocumented)
    protected readonly derivedWeekLabel: _angular_core.Signal<TranslatableString>;
    readonly disabledTime: _angular_core.ModelSignal<boolean>;
    // (undocumented)
    protected get endDate(): Date | undefined;
    focusActiveCell(): void;
    readonly focusedDate: _angular_core.ModelSignal<Date | undefined>;
    protected readonly forceFocus: _angular_core.Signal<boolean>;
    readonly hideTimeToggle: _angular_core.InputSignal<boolean>;
    // (undocumented)
    protected get hideWeekNumbers(): boolean;
    // (undocumented)
    protected readonly includeTimeLabel: _angular_core.Signal<TranslatableString>;
    readonly initialFocus: _angular_core.InputSignal<boolean>;
    // (undocumented)
    protected months: string[];
    // (undocumented)
    protected monthViewSwitchTo: 'month' | 'week';
    readonly nextLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnInit(): void;
    // (undocumented)
    protected onActiveHoverChange(event?: Cell): void;
    readonly previousLabel: _angular_core.InputSignal<TranslatableString>;
    readonly rangeType: _angular_core.ModelSignal<RangeType>;
    // (undocumented)
    protected readonly requireFocus: _angular_core.WritableSignal<boolean>;
    protected selectionChange(selection: Date): void;
    // (undocumented)
    protected get startDate(): Date | undefined;
    // (undocumented)
    protected switchId: string;
    protected time: FormControl<Date | undefined>;
    readonly time12h: _angular_core.InputSignalWithTransform<boolean | undefined, unknown>;
    // (undocumented)
    protected timepickerId: string;
    readonly timepickerLabel: _angular_core.InputSignal<string | undefined>;
    // (undocumented)
    protected timeSelected(newTime?: Date): void;
    // (undocumented)
    protected toggleDisabledTime(): void;
    protected readonly view: _angular_core.WritableSignal<ViewType>;
    // (undocumented)
    protected get weekStartDay(): WeekStart;
    protected yearViewSwitchTo: 'month' | 'week';
    // (undocumented)
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<SiDatepickerComponent, "si-datepicker", never, { "focusedDate": { "alias": "focusedDate"; "required": false; "isSignal": true; }; "date": { "alias": "date"; "required": false; "isSignal": true; }; "dateRange": { "alias": "dateRange"; "required": false; "isSignal": true; }; "dateRangeRole": { "alias": "dateRangeRole"; "required": false; "isSignal": true; }; "initialFocus": { "alias": "initialFocus"; "required": false; "isSignal": true; }; "disabledTime": { "alias": "disabledTime"; "required": false; "isSignal": true; }; "config": { "alias": "config"; "required": false; "isSignal": true; }; "previousLabel": { "alias": "previousLabel"; "required": false; "isSignal": true; }; "nextLabel": { "alias": "nextLabel"; "required": false; "isSignal": true; }; "calenderWeekLabel": { "alias": "calenderWeekLabel"; "required": false; "isSignal": true; }; "calendarWeekLabel": { "alias": "calendarWeekLabel"; "required": false; "isSignal": true; }; "time12h": { "alias": "time12h"; "required": false; "isSignal": true; }; "rangeType": { "alias": "rangeType"; "required": false; "isSignal": true; }; "minMonth": { "alias": "minMonth"; "required": false; "isSignal": true; }; "maxMonth": { "alias": "maxMonth"; "required": false; "isSignal": true; }; "hideTimeToggle": { "alias": "hideTimeToggle"; "required": false; "isSignal": true; }; "hideCalendar": { "alias": "hideCalendar"; "required": false; "isSignal": true; }; "timepickerLabel": { "alias": "timepickerLabel"; "required": false; "isSignal": true; }; "activeHover": { "alias": "activeHover"; "required": false; "isSignal": true; }; }, { "focusedDate": "focusedDateChange"; "date": "dateChange"; "dateRange": "dateRangeChange"; "disabledTime": "disabledTimeChange"; "config": "configChange"; "rangeType": "rangeTypeChange"; "activeHover": "activeHoverChange"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SiDatepickerComponent, never>;
}

// @public (undocumented)
export class SiDatepickerDirective extends SiDateInputDirective implements AfterViewInit {
    readonly autoClose: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    protected focusChange(): void;
    // (undocumented)
    ngAfterViewInit(): void;
    protected onBlur(event: FocusEvent): void;
    protected onClick(): void;
    protected onDateChanged(date?: Date): void;
    // (undocumented)
    protected onTab(): void;
    // (undocumented)
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<SiDatepickerDirective, "[siDatepicker]", ["siDatepicker"], { "autoClose": { "alias": "autoClose"; "required": false; "isSignal": true; }; }, {}, never, never, true, [{ directive: typeof SiDatepickerOverlayDirective; inputs: {}; outputs: { "siDatepickerClose": "siDatepickerClose"; }; }]>;
    // (undocumented)
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SiDatepickerDirective, never>;
}

// @public (undocumented)
export class SiDatepickerModule {
    // (undocumented)
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SiDatepickerModule, never>;
    // (undocumented)
    static ɵinj: _angular_core.ɵɵInjectorDeclaration<SiDatepickerModule>;
    // (undocumented)
    static ɵmod: _angular_core.ɵɵNgModuleDeclaration<SiDatepickerModule, never, [typeof SiCalendarButtonComponent, typeof SiDateInputDirective, typeof SiDatepickerComponent, typeof SiDatepickerDirective, typeof SiDateRangeComponent, typeof SiTimepickerComponent], [typeof SiCalendarButtonComponent, typeof SiDateInputDirective, typeof SiDatepickerComponent, typeof SiDatepickerDirective, typeof SiDateRangeComponent, typeof SiTimepickerComponent]>;
}

// @public (undocumented)
export class SiDatepickerOverlayComponent implements OnChanges, OnInit, OnDestroy {
    // (undocumented)
    protected activeHover?: Cell;
    // (undocumented)
    protected readonly completeAnimation: _angular_core.WritableSignal<boolean>;
    readonly config: _angular_core.InputSignal<DatepickerConfig>;
    readonly date: _angular_core.ModelSignal<Date | undefined>;
    // (undocumented)
    protected readonly datepicker: _angular_core.Signal<SiDatepickerComponent>;
    readonly dateRange: _angular_core.ModelSignal<DateRange | undefined>;
    readonly disabledTimeChange: _angular_core.OutputEmitterRef<boolean>;
    // (undocumented)
    protected disableTime: boolean;
    // (undocumented)
    protected readonly firstDatepickerConfig: _angular_core.WritableSignal<DatepickerConfig>;
    // (undocumented)
    protected firstDatepickerFocusDateChange(newFocusedDate?: Date): void;
    focusActiveCell(): void;
    readonly initialFocus: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly isMobile: _angular_core.InputSignal<boolean>;
    // (undocumented)
    protected readonly isTwoMonthDateRange: _angular_core.Signal<boolean>;
    // (undocumented)
    protected readonly maxMonth: _angular_core.WritableSignal<Date | undefined>;
    // (undocumented)
    protected readonly minMonth: _angular_core.WritableSignal<Date | undefined>;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    readonly rangeType: _angular_core.ModelSignal<"START" | "END" | undefined>;
    // (undocumented)
    protected readonly secondDatepickerConfig: _angular_core.WritableSignal<DatepickerConfig>;
    // (undocumented)
    protected secondDatepickerFocusDateChange(newFocusedDate?: Date): void;
    readonly time12h: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<SiDatepickerOverlayComponent, "si-datepicker-overlay", never, { "initialFocus": { "alias": "initialFocus"; "required": false; "isSignal": true; }; "config": { "alias": "config"; "required": false; "isSignal": true; }; "date": { "alias": "date"; "required": false; "isSignal": true; }; "dateRange": { "alias": "dateRange"; "required": false; "isSignal": true; }; "rangeType": { "alias": "rangeType"; "required": false; "isSignal": true; }; "time12h": { "alias": "time12h"; "required": false; "isSignal": true; }; "isMobile": { "alias": "isMobile"; "required": false; "isSignal": true; }; }, { "date": "dateChange"; "dateRange": "dateRangeChange"; "rangeType": "rangeTypeChange"; "disabledTimeChange": "disabledTimeChange"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SiDatepickerOverlayComponent, never>;
}

// @public
export class SiDatepickerOverlayDirective implements OnDestroy {
    closeAfterSelection(): void;
    closeOverlay(): undefined;
    contains(element: HTMLElement): boolean;
    // (undocumented)
    protected createDesktopOverlay(): void;
    // (undocumented)
    protected createMobileOverlay(): void;
    focus(focus?: boolean): this;
    isShown(): ComponentRef<SiDatepickerOverlayComponent> | undefined;
    // (undocumented)
    ngOnDestroy(): void;
    setInputs(inputs?: DatepickerInputPartial): this;
    showOverlay(focus?: boolean, inputs?: DatepickerInputPartial): ComponentRef<SiDatepickerOverlayComponent>;
    readonly siDatepickerClose: _angular_core.OutputEmitterRef<CloseCause>;
    // (undocumented)
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<SiDatepickerOverlayDirective, "[siDatepickerOverlay]", ["siDatepickerOverlay"], {}, { "siDatepickerClose": "siDatepickerClose"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SiDatepickerOverlayDirective, never>;
}

// @public (undocumented)
export class SiDateRangeComponent implements ControlValueAccessor, Validator, AfterViewInit, OnChanges, SiFormItemControl {
    readonly ariaLabelCalendarButton: _angular_core.InputSignal<TranslatableString>;
    readonly autoClose: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    protected readonly disabled: _angular_core.Signal<boolean>;
    readonly disabledInput: _angular_core.InputSignal<boolean>;
    readonly disabledTimeChange: _angular_core.OutputEmitterRef<boolean>;
    readonly endDatePlaceholder: _angular_core.InputSignal<TranslatableString>;
    readonly endTimeLabel: _angular_core.InputSignal<TranslatableString>;
    readonly errormessageId: _angular_core.InputSignal<string>;
    // (undocumented)
    protected readonly icons: Record<"elementCalendar", string>;
    // (undocumented)
    readonly id: _angular_core.InputSignal<string>;
    // (undocumented)
    readonly labelledby: string;
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    protected onFocusOut(event: FocusEvent): void;
    protected onInputChanged(dateRange: DateRange): void;
    readonly readonly: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    registerOnChange(fn: any): void;
    // (undocumented)
    registerOnTouched(fn: () => void): void;
    // (undocumented)
    setDisabledState(isDisabled: boolean): void;
    // (undocumented)
    protected show(): void;
    readonly siDatepickerConfig: _angular_core.ModelSignal<DatepickerInputConfig>;
    readonly siDatepickerRangeChange: _angular_core.OutputEmitterRef<DateRange | undefined>;
    readonly startDatePlaceholder: _angular_core.InputSignal<TranslatableString>;
    readonly startTimeLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    validate(c: AbstractControl): ValidationErrors | null;
    readonly value: _angular_core.ModelSignal<DateRange | undefined>;
    // (undocumented)
    writeValue(dateRange: DateRange): void;
    // (undocumented)
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<SiDateRangeComponent, "si-date-range", never, { "id": { "alias": "id"; "required": false; "isSignal": true; }; "siDatepickerConfig": { "alias": "siDatepickerConfig"; "required": false; "isSignal": true; }; "startDatePlaceholder": { "alias": "startDatePlaceholder"; "required": false; "isSignal": true; }; "endDatePlaceholder": { "alias": "endDatePlaceholder"; "required": false; "isSignal": true; }; "ariaLabelCalendarButton": { "alias": "ariaLabelCalendarButton"; "required": false; "isSignal": true; }; "startTimeLabel": { "alias": "startTimeLabel"; "required": false; "isSignal": true; }; "endTimeLabel": { "alias": "endTimeLabel"; "required": false; "isSignal": true; }; "autoClose": { "alias": "autoClose"; "required": false; "isSignal": true; }; "disabledInput": { "alias": "disabled"; "required": false; "isSignal": true; }; "readonly": { "alias": "readonly"; "required": false; "isSignal": true; }; "value": { "alias": "value"; "required": false; "isSignal": true; }; "errormessageId": { "alias": "errormessageId"; "required": false; "isSignal": true; }; }, { "siDatepickerConfig": "siDatepickerConfigChange"; "siDatepickerRangeChange": "siDatepickerRangeChange"; "disabledTimeChange": "disabledTimeChange"; "value": "valueChange"; }, never, never, true, [{ directive: typeof SiDatepickerOverlayDirective; inputs: {}; outputs: { "siDatepickerClose": "siDatepickerClose"; }; }]>;
    // (undocumented)
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SiDateRangeComponent, never>;
}

// @public (undocumented)
export class SiTimepickerComponent implements ControlValueAccessor, Validator, SiFormItemControl {
    constructor();
    // (undocumented)
    protected readonly disabled: _angular_core.Signal<boolean>;
    readonly disabledInput: _angular_core.InputSignal<boolean>;
    readonly errormessageId: _angular_core.InputSignal<string>;
    // (undocumented)
    protected focusChange(event: FocusOrigin): void;
    protected focusNext(event: Event): void;
    protected handleKeyPressEvent(event: KeyboardEvent): void;
    protected hasInvalidUnit(): boolean;
    readonly hideLabels: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    readonly hoursAriaLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    readonly hoursLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    readonly hoursPlaceholder: _angular_core.InputSignal<string>;
    // (undocumented)
    readonly id: _angular_core.InputSignal<string>;
    // (undocumented)
    readonly inputCompleted: _angular_core.OutputEmitterRef<void>;
    // (undocumented)
    readonly isValid: _angular_core.OutputEmitterRef<boolean>;
    // (undocumented)
    readonly labelledby: string;
    readonly max: _angular_core.InputSignal<Date | undefined>;
    // (undocumented)
    protected readonly meridian: _angular_core.WritableSignal<"" | "am" | "pm">;
    // (undocumented)
    readonly meridianChange: _angular_core.OutputEmitterRef<string>;
    // (undocumented)
    readonly meridians: _angular_core.InputSignal<string[] | undefined>;
    // (undocumented)
    readonly meridiansAriaLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    readonly meridiansLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    readonly millisecondsAriaLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    readonly millisecondsLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    readonly millisecondsPlaceholder: _angular_core.InputSignal<string>;
    readonly min: _angular_core.InputSignal<Date | undefined>;
    // (undocumented)
    readonly minutesAriaLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    readonly minutesLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    readonly minutesPlaceholder: _angular_core.InputSignal<string>;
    // (undocumented)
    protected readonly periods: _angular_core.Signal<string[]>;
    // (undocumented)
    readonly readonly: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    registerOnChange(fn: any): void;
    // (undocumented)
    registerOnTouched(fn: () => void): void;
    // (undocumented)
    readonly secondsAriaLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    readonly secondsLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    readonly secondsPlaceholder: _angular_core.InputSignal<string>;
    // (undocumented)
    setDisabledState(isDisabled: boolean): void;
    readonly showMeridian: _angular_core.InputSignal<boolean | undefined>;
    // (undocumented)
    readonly showMilliseconds: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    readonly showMinutes: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    readonly showSeconds: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    protected readonly timeControls: _angular_forms.FormGroup<{
        hours: _angular_forms.FormControl<string>;
        minutes: _angular_forms.FormControl<string>;
        seconds: _angular_forms.FormControl<string>;
        milliseconds: _angular_forms.FormControl<string>;
    }>;
    // (undocumented)
    protected toggleMeridian(): void;
    // (undocumented)
    protected toHtmlInputElement: (target?: EventTarget | null) => HTMLInputElement;
    // (undocumented)
    protected readonly units: _angular_core.Signal<Config[]>;
    // (undocumented)
    protected updateField(name: keyof Value, value: string): void;
    // (undocumented)
    protected readonly use12HourClock: _angular_core.Signal<boolean>;
    // (undocumented)
    protected validateMax(control: AbstractControl): ValidationErrors | null;
    // (undocumented)
    protected validateMin(control: AbstractControl): ValidationErrors | null;
    // (undocumented)
    protected validateTime(name: string): ValidatorFn;
    // (undocumented)
    writeValue(obj?: Date | string): void;
    // (undocumented)
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<SiTimepickerComponent, "si-timepicker", never, { "id": { "alias": "id"; "required": false; "isSignal": true; }; "disabledInput": { "alias": "disabled"; "required": false; "isSignal": true; }; "hoursLabel": { "alias": "hoursLabel"; "required": false; "isSignal": true; }; "minutesLabel": { "alias": "minutesLabel"; "required": false; "isSignal": true; }; "secondsLabel": { "alias": "secondsLabel"; "required": false; "isSignal": true; }; "millisecondsLabel": { "alias": "millisecondsLabel"; "required": false; "isSignal": true; }; "hideLabels": { "alias": "hideLabels"; "required": false; "isSignal": true; }; "hoursAriaLabel": { "alias": "hoursAriaLabel"; "required": false; "isSignal": true; }; "minutesAriaLabel": { "alias": "minutesAriaLabel"; "required": false; "isSignal": true; }; "secondsAriaLabel": { "alias": "secondsAriaLabel"; "required": false; "isSignal": true; }; "millisecondsAriaLabel": { "alias": "millisecondsAriaLabel"; "required": false; "isSignal": true; }; "hoursPlaceholder": { "alias": "hoursPlaceholder"; "required": false; "isSignal": true; }; "minutesPlaceholder": { "alias": "minutesPlaceholder"; "required": false; "isSignal": true; }; "secondsPlaceholder": { "alias": "secondsPlaceholder"; "required": false; "isSignal": true; }; "millisecondsPlaceholder": { "alias": "millisecondsPlaceholder"; "required": false; "isSignal": true; }; "meridians": { "alias": "meridians"; "required": false; "isSignal": true; }; "meridiansLabel": { "alias": "meridiansLabel"; "required": false; "isSignal": true; }; "meridiansAriaLabel": { "alias": "meridiansAriaLabel"; "required": false; "isSignal": true; }; "showMinutes": { "alias": "showMinutes"; "required": false; "isSignal": true; }; "showSeconds": { "alias": "showSeconds"; "required": false; "isSignal": true; }; "showMilliseconds": { "alias": "showMilliseconds"; "required": false; "isSignal": true; }; "showMeridian": { "alias": "showMeridian"; "required": false; "isSignal": true; }; "min": { "alias": "min"; "required": false; "isSignal": true; }; "max": { "alias": "max"; "required": false; "isSignal": true; }; "readonly": { "alias": "readonly"; "required": false; "isSignal": true; }; "errormessageId": { "alias": "errormessageId"; "required": false; "isSignal": true; }; }, { "isValid": "isValid"; "meridianChange": "meridianChange"; "inputCompleted": "inputCompleted"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SiTimepickerComponent, never>;
}

// @public
export const today: () => Date;

// @public (undocumented)
export const WEEK_START_OFFSET: {
    monday: number;
    saturday: number;
    sunday: number;
};

// @public
export type WeekStart = 'monday' | 'saturday' | 'sunday' | undefined;

// (No @packageDocumentation comment for this package)

```
