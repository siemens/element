## Public API Report File for "@siemens/element-ng_ai-chat"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AfterContentInit } from '@angular/core';
import * as _angular_core from '@angular/core';
import { Attachment } from '@siemens/element-ng/chat-messages';
import { BackgroundColorVariant } from '@siemens/element-ng/common';
import { ChatInputAttachment } from '@siemens/element-ng/chat-messages';
import { FileUploadError } from '@siemens/element-ng/file-uploader';
import * as i1 from '@siemens/element-ng/resize-observer';
import { isSignal } from '@angular/core';
import { MenuItemAction } from '@siemens/element-ng/menu';
import { MessageAction } from '@siemens/element-ng/chat-messages';
import { OnDestroy } from '@angular/core';
import { Signal } from '@angular/core';
import { TemplateRef } from '@angular/core';
import { TranslatableString } from '@siemens/element-translate-ng/translate';

// @public (undocumented)
export interface AiChatMessage extends BaseChatMessage {
    actions?: MessageAction[];
    content: string | Signal<string>;
    type: 'ai';
}

// @public
export interface BaseChatMessage {
    content?: string | Signal<string>;
    loading?: boolean | Signal<boolean>;
    template?: TemplateRef<any>;
    type: 'user' | 'ai' | 'tool';
}

// @public (undocumented)
export type ChatMessage = UserChatMessage | AiChatMessage | ToolChatMessage;

// @public (undocumented)
export class SiChatContainerComponent implements OnDestroy, AfterContentInit {
    constructor();
    readonly accept: _angular_core.InputSignal<string | undefined>;
    readonly actionParam: _angular_core.InputSignal<unknown>;
    readonly aiIcon: _angular_core.InputSignal<string>;
    readonly allowAttachments: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly attachFileLabel: _angular_core.InputSignal<TranslatableString>;
    readonly attachments: _angular_core.ModelSignal<ChatInputAttachment[]>;
    readonly colorVariant: _angular_core.InputSignal<BackgroundColorVariant>;
    readonly disableAutoFocus: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly disabled: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly disableInterrupt: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly disclaimer: _angular_core.InputSignal<TranslatableString | undefined>;
    // (undocumented)
    protected readonly displayMessages: Signal<ChatMessage[]>;
    // (undocumented)
    protected readonly emptyStateContext: Signal<{
        title: TranslatableString;
        description: TranslatableString;
    }>;
    readonly emptyStateDescription: _angular_core.InputSignal<TranslatableString>;
    readonly emptyStateTitle: _angular_core.InputSignal<TranslatableString>;
    focus(): void;
    // (undocumented)
    protected focusInput(): void;
    protected getContentValue<T extends string | object>(content: T | Signal<T> | undefined): T;
    protected getLoadingState(loading: boolean | Signal<boolean> | undefined, content: string | object | Signal<string | object> | undefined, applyGlobalLoading?: boolean, allowEmptyContent?: boolean): boolean;
    // (undocumented)
    protected getMessagePrimaryActions(message: ChatMessage): MessageAction[];
    // (undocumented)
    protected getMessageSecondaryActions(message: ChatMessage): MenuItemAction[];
    // (undocumented)
    protected getOutputValue(outputValue: string | object | Signal<string | object> | undefined): string | object | undefined;
    readonly inputActions: _angular_core.InputSignal<MessageAction[]>;
    protected readonly inputInterruptible: Signal<boolean>;
    readonly inputLabel: _angular_core.InputSignal<string>;
    readonly inputPlaceholder: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    protected readonly inputPrimaryActions: Signal<MessageAction[]>;
    // (undocumented)
    protected readonly inputSecondaryActions: Signal<MenuItemAction[]>;
    protected readonly inputSending: Signal<boolean>;
    readonly inputValue: _angular_core.ModelSignal<string>;
    readonly interrupt: _angular_core.OutputEmitterRef<void>;
    readonly interrupting: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    protected readonly isEmpty: Signal<boolean>;
    // (undocumented)
    protected isLatestMessage(message: ChatMessage): boolean;
    // (undocumented)
    protected readonly isLoading: Signal<boolean>;
    protected readonly isSignal: typeof isSignal;
    readonly loading: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    protected markdownRenderer: (text: string) => Node;
    readonly maxFileSize: _angular_core.InputSignal<number>;
    readonly messages: _angular_core.InputSignal<ChatMessage[] | undefined>;
    readonly messageSent: _angular_core.OutputEmitterRef<{
        content: string;
        attachments: ChatInputAttachment[];
    }>;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    readonly noAutoScroll: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    protected onFileError(error: FileUploadError): void;
    // (undocumented)
    protected onInterrupt(): void;
    // (undocumented)
    protected onMessageSent(event: {
        content: string;
        attachments: ChatInputAttachment[];
    }): void;
    // (undocumented)
    protected onScroll(): void;
    readonly removeAttachmentLabel: _angular_core.InputSignal<TranslatableString>;
    readonly secondaryActionsLabel: _angular_core.InputSignal<TranslatableString>;
    readonly sendButtonIcon: _angular_core.InputSignal<string>;
    readonly sendButtonLabel: _angular_core.InputSignal<TranslatableString>;
    readonly sending: _angular_core.InputSignalWithTransform<boolean, unknown>;
    // (undocumented)
    protected shouldAutoExpandInputArguments(message: ChatMessage): boolean;
    // (undocumented)
    protected shouldAutoExpandOutput(message: ChatMessage): boolean;
    readonly statusAction: _angular_core.InputSignal<{
        title: string;
        href: string;
        target?: string;
    } | undefined>;
    readonly statusHeading: _angular_core.InputSignal<string | undefined>;
    readonly statusMessage: _angular_core.InputSignal<string | undefined>;
    readonly statusSeverity: _angular_core.InputSignal<"info" | "success" | "warning" | "danger" | "caution" | "critical" | undefined>;
    readonly toolInputArgumentsLabel: _angular_core.InputSignal<TranslatableString>;
    readonly toolOutputLabel: _angular_core.InputSignal<TranslatableString>;
    // (undocumented)
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<SiChatContainerComponent, "si-chat-container", never, { "messages": { "alias": "messages"; "required": false; "isSignal": true; }; "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; "sending": { "alias": "sending"; "required": false; "isSignal": true; }; "loading": { "alias": "loading"; "required": false; "isSignal": true; }; "disableInterrupt": { "alias": "disableInterrupt"; "required": false; "isSignal": true; }; "interrupting": { "alias": "interrupting"; "required": false; "isSignal": true; }; "disclaimer": { "alias": "disclaimer"; "required": false; "isSignal": true; }; "inputActions": { "alias": "inputActions"; "required": false; "isSignal": true; }; "allowAttachments": { "alias": "allowAttachments"; "required": false; "isSignal": true; }; "noAutoScroll": { "alias": "noAutoScroll"; "required": false; "isSignal": true; }; "aiIcon": { "alias": "aiIcon"; "required": false; "isSignal": true; }; "accept": { "alias": "accept"; "required": false; "isSignal": true; }; "maxFileSize": { "alias": "maxFileSize"; "required": false; "isSignal": true; }; "attachments": { "alias": "attachments"; "required": false; "isSignal": true; }; "colorVariant": { "alias": "colorVariant"; "required": false; "isSignal": true; }; "inputValue": { "alias": "inputValue"; "required": false; "isSignal": true; }; "inputPlaceholder": { "alias": "inputPlaceholder"; "required": false; "isSignal": true; }; "disableAutoFocus": { "alias": "disableAutoFocus"; "required": false; "isSignal": true; }; "statusSeverity": { "alias": "statusSeverity"; "required": false; "isSignal": true; }; "statusHeading": { "alias": "statusHeading"; "required": false; "isSignal": true; }; "statusMessage": { "alias": "statusMessage"; "required": false; "isSignal": true; }; "statusAction": { "alias": "statusAction"; "required": false; "isSignal": true; }; "actionParam": { "alias": "actionParam"; "required": false; "isSignal": true; }; "emptyStateTitle": { "alias": "emptyStateTitle"; "required": false; "isSignal": true; }; "emptyStateDescription": { "alias": "emptyStateDescription"; "required": false; "isSignal": true; }; "inputLabel": { "alias": "inputLabel"; "required": false; "isSignal": true; }; "sendButtonLabel": { "alias": "sendButtonLabel"; "required": false; "isSignal": true; }; "sendButtonIcon": { "alias": "sendButtonIcon"; "required": false; "isSignal": true; }; "attachFileLabel": { "alias": "attachFileLabel"; "required": false; "isSignal": true; }; "removeAttachmentLabel": { "alias": "removeAttachmentLabel"; "required": false; "isSignal": true; }; "secondaryActionsLabel": { "alias": "secondaryActionsLabel"; "required": false; "isSignal": true; }; "toolInputArgumentsLabel": { "alias": "toolInputArgumentsLabel"; "required": false; "isSignal": true; }; "toolOutputLabel": { "alias": "toolOutputLabel"; "required": false; "isSignal": true; }; }, { "attachments": "attachmentsChange"; "inputValue": "inputValueChange"; "messageSent": "messageSent"; "interrupt": "interrupt"; }, never, ["*", "[slot=input-actions]"], true, [{ directive: typeof i1.SiResponsiveContainerDirective; inputs: {}; outputs: {}; }]>;
    // (undocumented)
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SiChatContainerComponent, never>;
}

// @public (undocumented)
export interface TemplateChatMessage extends BaseChatMessage {
    template: TemplateRef<any>;
}

// @public (undocumented)
export interface ToolChatMessage extends BaseChatMessage {
    autoExpandInputArguments?: boolean;
    autoExpandOutput?: boolean;
    icon?: string;
    inputArguments?: string | object;
    name: string;
    output?: string | object | Signal<string | object>;
    type: 'tool';
}

// @public (undocumented)
export interface UserChatMessage extends BaseChatMessage {
    actions?: MessageAction[];
    attachments?: Attachment[];
    content: string;
    type: 'user';
}

// (No @packageDocumentation comment for this package)

```
